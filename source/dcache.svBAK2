/*
  File name:   dcache.sv
  Created:     10/21/2014
  Author:      Damaso Flores Garcia & Aharon Hannan
  Lab Section: 437 - 03
  Version:     1.0  Initial Design Entry
  Description: Data cache Unit
*/

`include "datapath_cache_if.vh"
`include "cache_control_if.vh"
`include "cpu_types_pkg.vh"

module dcache (
  input logic CLK, nRST,
  datapath_cache_if dcif,
  cache_control_if ccif
);

  //import types
  import cpu_types_pkg::*;

  parameter CPUID = 0;
  parameter BAD = 32'h00BADBAD;

  typedef struct packed {
    logic [25:0] tag;
    logic valid, dirty;
    word_t [1:0] data;
  } block_t;

  typedef struct packed {
    block_t [1:0] way;
  } dcache_t;

  // Local Vars
  dcache_t cache[7:0];
  // word_t [1:0] data;
  logic set_dirty, is_dirty, sel, way, enable, flush, data_sel;
  logic [3:0] c_ind, c_jay, n_ind, n_jay;
  logic [25:0] tag, snoop_tag;
  logic [2:0] index, snoop_index;
  logic [1:0] hit, snoop_hit;
  logic [7:0] lru, next_lru;
  word_t hit_counter, next_hit_counter;
  // State vars
  typedef enum bit [4:0] {IDLE, INV_SC, TAGCHK, SNPCHK, READ, WRITE, TRANS, WAIT0, WAIT1, FET0, FET1, WB0, WB1, SNPWB0, SNPWB1, FLUSH_I, FLUSH_J, HITCOUNT, HALT} state_t;
  state_t state, next_state;  
  // Parse dmemaddr
  assign tag = dcif.dmemaddr[31:6];
  assign index = dcif.dmemaddr[5:3];
  assign snoop_tag = ccif.ccsnoopaddr[CPUID][31:6];
  assign snoop_index = ccif.ccsnoopaddr[CPUID][5:3];
  assign sel = dcif.dmemaddr[2];
  // Hit logic
  assign hit[0] = cache[index].way[0].valid && (cache[index].way[0].tag == tag);
  assign hit[1] = cache[index].way[1].valid && (cache[index].way[1].tag == tag);
  assign snoop_hit[0] = cache[snoop_index].way[0].valid && (cache[snoop_index].way[0].tag == snoop_tag);
  assign snoop_hit[1] = cache[snoop_index].way[1].valid && (cache[snoop_index].way[1].tag == snoop_tag);
  assign way = (hit == 0) ? lru[index] : hit[1];
  assign is_dirty = cache[index].way[way].dirty;
  // Flush signal
  assign flush = dcif.halt;
  // LL and SC struct
  typedef struct packed {
    word_t register;
    logic success;
  } link_t;
  // one link register
  link_t link, next;
  // Cache Reg
  always_ff@(posedge CLK, negedge nRST) begin
    if(~nRST) begin
      cache[0] <= '0;
      cache[1] <= '0;
      cache[2] <= '0;
      cache[3] <= '0;
      cache[4] <= '0;
      cache[5] <= '0;
      cache[6] <= '0;
      cache[7] <= '0;
    end else if(enable) begin
      if(flush) begin
        cache[c_ind].way[c_jay].dirty <= set_dirty;
      end else if(state == SNPWB1) begin
        cache[snoop_index].way[snoop_hit[1]].valid <= ~ccif.ccinv[CPUID];
        cache[snoop_index].way[snoop_hit[1]].dirty <= set_dirty;
      end else begin
        cache[index].way[way].dirty <= set_dirty;
        if((state == FET0) || (state == FET1)) begin
          cache[index].way[way].tag <= tag;
          cache[index].way[way].valid <= 1;
        end
        if(state == WRITE) begin
          cache[index].way[way].data[data_sel] <= dcif.dmemstore;
        end else begin
          cache[index].way[way].data[data_sel] <= ccif.dload[CPUID];
        end
      end
    end
  end
  // State Machine Reg
  always_ff@(posedge CLK, negedge nRST) begin
    if(~nRST) begin
      lru <= '0;
      state <= IDLE;
      hit_counter <= '0;
      c_ind <= '0;
      c_jay <= '0;
      link <= '0;
    end else begin
      lru <= next_lru;
      state <= next_state;
      hit_counter <= next_hit_counter;
      c_ind <= n_ind;
      c_jay <= n_jay;
      link.register <= next.register;
      link.success <= next.success;
    end
  end

  always_comb begin : nstate_logic
    next_state = IDLE;
    case (state)
      IDLE: begin
        if(ccif.ccwait[CPUID]) begin
          next_state = SNPCHK;
        end else if(dcif.dmemWEN | dcif.dmemREN) begin
          if(dcif.dmemWEN && dcif.datomic) begin
            if((dcif.dmemaddr == link.register) && link.success) begin
              next_state = TAGCHK;
            end else begin
              next_state = INV_SC;
            end
          end else begin
            next_state = TAGCHK;
          end
        end else if(flush) begin
          next_state = FLUSH_I;
        end else begin 
          next_state = IDLE;
        end
      end
      INV_SC: begin
        next_state = IDLE;
      end
      TAGCHK: begin
        if(ccif.ccwait[CPUID]) begin
          next_state = SNPCHK;
        end else if(hit && dcif.dmemREN) begin
          next_state = READ;
        end else if(hit && dcif.dmemWEN) begin
          if(is_dirty) begin
            next_state = WRITE;
          end else begin
            next_state = TRANS;
          end
        end else if((hit == 0) & !is_dirty) begin
          next_state = TRANS;
        end else if((hit == 0) & is_dirty) begin
          next_state = WB0;
        end else begin
          next_state = TAGCHK;
        end
      end
      SNPCHK: begin
        if(snoop_hit) begin
          next_state = SNPWB0;
        end else begin
          next_state = IDLE;
        end
      end
      READ: begin
        if(ccif.ccwait[CPUID]) begin
          next_state = SNPCHK;
        end else begin
          next_state = IDLE;
        end
      end
      WRITE: begin
        if(ccif.ccwait[CPUID]) begin
          next_state = SNPCHK;
        end else begin
          next_state = IDLE;
        end
      end
      TRANS: begin
        if(ccif.ccwait[CPUID]) begin
          next_state = SNPCHK;
        end else if(ccif.ccwait[1-CPUID]) begin
          next_state = WAIT0;
        end else begin
          next_state = TRANS;
        end
      end
      WAIT0: begin
        if(ccif.ccwait[CPUID]) begin
          next_state = SNPCHK;
        end else begin
          next_state = FET0;
        end
      end
      WAIT1: begin        
      end
      FET0: begin
        if(ccif.ccwait[CPUID]) begin
          next_state = SNPCHK;
        end else if(~ccif.dwait[CPUID]) begin
          next_state = FET1;
        end else begin
          next_state = FET0;
        end
      end
      FET1: begin
        if(ccif.ccwait[CPUID]) begin
          next_state = SNPCHK;
        end else if(~ccif.dwait[CPUID]) begin
          if(dcif.dmemWEN) begin
            next_state = WRITE;
          end else if(dcif.dmemREN) begin
            next_state = READ;
          end else begin
            next_state = FET1;
          end
        end else begin
          next_state = FET1;
        end
      end
      WB0: begin
        if(ccif.ccwait[CPUID]) begin
          next_state = SNPCHK;
        end else if(~ccif.dwait[CPUID]) begin
          next_state = WB1;
        end else begin
          next_state = WB0;
        end
      end
      WB1: begin
        if(ccif.ccwait[CPUID]) begin
          next_state = SNPCHK;
        end else if(~ccif.dwait[CPUID]) begin
          if(flush) begin
            next_state = FLUSH_I;
          end else begin
            next_state = TRANS;
          end
        end else begin
          next_state = WB1;
        end
      end
      SNPWB0: begin
        if(~ccif.dwait[CPUID]) begin
          next_state = SNPWB1;
        end else begin
          next_state = SNPWB0;
        end
      end
      SNPWB1: begin
        if(~ccif.dwait[CPUID]) begin
          next_state = IDLE;
        end else begin
          next_state = SNPWB1;
        end
      end
      FLUSH_I: begin
        if(c_ind == 8) begin
          next_state = HALT;
        end else if(cache[c_ind].way[0].dirty | cache[c_ind].way[1].dirty) begin
          next_state = FLUSH_J;
        end else begin
          next_state = FLUSH_I;
        end
      end
      FLUSH_J: begin
        if(c_jay == 2) begin
          next_state = FLUSH_I;
        end else if(cache[c_ind].way[c_jay].dirty) begin
          next_state = WB0;
        end else begin
          next_state = FLUSH_J;
        end
      end
      HITCOUNT: begin
        next_state = HALT;
      end
      HALT: begin
        next_state = HALT;
      end
    endcase
  end

  assign ccif.ccwrite[CPUID] = dcif.dmemWEN;

  always_comb begin : output_logic
    next_hit_counter = hit_counter;
    dcif.dmemload = BAD;
    next_lru = lru;
    dcif.dhit = 0;
    enable = 0;
    set_dirty = is_dirty;
    ccif.dREN[CPUID] = 0;
    ccif.dWEN[CPUID] = 0;
    ccif.daddr[CPUID] = BAD;
    ccif.dstore[CPUID] = BAD;
    n_ind = c_ind;
    n_jay = c_jay;
    dcif.flushed = 0;
    data_sel = 0;
    ccif.cctrans[CPUID] = 0;
    // LLSC
    next = link;
    case (state)
      IDLE: begin
      end
      TAGCHK: begin
        if(hit != 0) begin
          next_hit_counter = hit_counter + 1;
        end
      end
      INV_SC: begin
        dcif.dhit = 1;
        dcif.dmemload = 32'b0;
      end
      SNPCHK: begin
        if(snoop_hit) begin
          ccif.dWEN[CPUID] = 1;
        end else begin
          ccif.dWEN[CPUID] = 0;
        end
      end
      READ: begin
        dcif.dmemload = cache[index].way[way].data[sel];
        next_lru[index] = ~way;
        dcif.dhit = 1;
        // Load Link
        if(dcif.datomic) begin
          next.register = dcif.dmemaddr;
          next.success = 1;
        end
      end
      WRITE: begin
        data_sel = sel;
        set_dirty = 1;
        enable = 1;
        next_lru[index] = ~way;
        dcif.dhit = 1;
        // LLSC
        if(link.register == dcif.dmemaddr) begin
          if(dcif.datomic) begin
            dcif.dmemload = 32'b1;
          end
          next.success = 0;
        end
      end
      TRANS: begin
        ccif.cctrans[CPUID] = 1;
      end
      WAIT0: begin
        ccif.daddr[CPUID] = dcif.dmemaddr;
      end
      WAIT1: begin
      end
      FET0: begin
        ccif.dREN[CPUID] = 1;
        ccif.daddr[CPUID] = ({tag, index, 3'b000});
        data_sel = 0;
        enable = 1;
      end
      FET1: begin
        ccif.dREN[CPUID] = 1;
        ccif.daddr[CPUID] = ({tag, index, 3'b100});
        data_sel = 1;
        enable = 1;
      end
      WB0: begin
        ccif.dWEN[CPUID] = 1;
        if(flush) begin
          ccif.daddr[CPUID] = ({cache[c_ind].way[c_jay].tag, 3'(c_ind), 3'b000});
          ccif.dstore[CPUID] = cache[c_ind].way[c_jay].data[0];
        end else begin
          ccif.daddr[CPUID] = ({cache[index].way[way].tag, index, 3'b000});
          ccif.dstore[CPUID] = cache[index].way[way].data[0];
        end
      end
      WB1: begin
        ccif.dWEN[CPUID] = 1;
        set_dirty = 0;
        enable = 1;
        if(flush) begin
          ccif.daddr[CPUID] = ({cache[c_ind].way[c_jay].tag, 3'(c_ind), 3'b100});
          ccif.dstore[CPUID] = cache[c_ind].way[c_jay].data[1];
        end else begin
          ccif.daddr[CPUID] = ({cache[index].way[way].tag, index, 3'b100});
          ccif.dstore[CPUID] = cache[index].way[way].data[1];
        end
        // LL SC
        if(link.register == ({cache[index].way[way].tag, index, 3'b100})) begin
          next.success = 0;
        end
      end
      SNPWB0: begin
        ccif.dWEN[CPUID] = 1;
        ccif.daddr[CPUID] = ({cache[snoop_index].way[snoop_hit[1]].tag, snoop_index, 3'b000});
        ccif.dstore[CPUID] = cache[snoop_index].way[snoop_hit[1]].data[0];
      end
      SNPWB1: begin
        ccif.dWEN[CPUID] = 1;
        set_dirty = 0;
        enable = 1;
        ccif.daddr[CPUID] = ({cache[snoop_index].way[snoop_hit[1]].tag, snoop_index, 3'b100});
        ccif.dstore[CPUID] = cache[snoop_index].way[snoop_hit[1]].data[1];
        // LLSC
        // if(link.register === ccif.ccsnoopaddr[CPUID]) begin
        //   next.success = 0;
        // end
      end
      FLUSH_I: begin
        if(c_ind == 8) begin
          n_ind = 0;
        end else if(cache[c_ind].way[0].dirty | cache[c_ind].way[1].dirty) begin
          n_ind = c_ind;
        end else begin
          n_ind = c_ind + 3'b001;
        end
      end
      FLUSH_J: begin
        if(c_jay == 2) begin
          n_jay = 0;
        end if(cache[c_ind].way[c_jay].dirty) begin
          n_jay = c_jay;
        end else begin
          n_jay = c_jay + 3'b001;
        end
      end
      HITCOUNT: begin
        ccif.dWEN[CPUID] = 1;
        ccif.daddr[CPUID] = 32'h3100;
        ccif.dstore[CPUID] = hit_counter;
      end
      HALT: begin
        dcif.flushed= dcif.halt;
      end
    endcase
  end

endmodule
